# -*- coding: utf-8 -*-
"""B19EE009_B19CSE107_Mini_Project_Mask_Detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11Fz0BuV5NGxeIqjn01zU7J8PrQlFqqS5
"""

import os
import numpy as np
import pandas as pd 
import matplotlib.pyplot as plt
import plotnine
import seaborn as sns
from plotnine import ggplot , geom_jitter , aes ,theme_light, geom_point
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score
from sklearn import metrics


from sklearn.neighbors import KNeighborsClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.linear_model import LogisticRegression
from sklearn import svm
from sklearn.linear_model import Perceptron
from sklearn.model_selection import GridSearchCV
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import RepeatedStratifiedKFold
from sklearn.decomposition import PCA
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA
from sklearn.naive_bayes import GaussianNB
from sklearn.feature_selection import RFE

from statistics import mean,stdev

from sklearn.preprocessing import StandardScaler

import missingno as msno

# run block of code and catch warnings
import warnings
warnings.filterwarnings("ignore")
from copy import deepcopy

!unzip '/content/drive/MyDrive/Kaggle/self-built-masked-face-recognition-dataset.zip'

path = '/content/self-built-masked-face-recognition-dataset'



IMG_DIR_list = os.listdir(path)

IMG_DIR_list = IMG_DIR_list[1:]

IMG_DIR_list

"""1 for masked and 0 for non masked"""

dir_url = os.path.join(path, IMG_DIR_list[0])
dir_url



img_file_urls_1 = []
for subdir in sorted(os.listdir(dir_url)):
  for file in (os.listdir(os.path.join(dir_url, subdir))):
    img_file_urls_1.append(os.path.join(os.path.join(dir_url, subdir), file))

len(img_file_urls_1)

img_file_urls_1

# img_file_urls_1 = []
# for root,d_names,f_names in os.walk(path):
#   for f in f_names:
#     img_file_urls_1.append(os.path.join(root, f))

# print("img_file_urls_1 = %s" %img_file_urls_1)

# print(dir_url)

# img_file_urls_1 = img_file_urls_1[1:]
# img_file_urls_1



import random
random.shuffle(img_file_urls_1)

import cv2
from PIL import Image
image_array_list_1 = []
for img_url in img_file_urls_1:
  img_array = cv2.imread(img_url, cv2.IMREAD_GRAYSCALE)
  img_pil = Image.fromarray(img_array)
  img_28x28 = np.array(img_pil.resize((28, 28), Image.ANTIALIAS))
  img_array = (img_28x28.flatten())
  img_array  = img_array.reshape(-1,1).T
  image_array_list_1.append(img_array.tolist()[0])

image_array_list_1 = np.array(image_array_list_1)

df_1 = pd.DataFrame(image_array_list_1)

df_1.head()

"""Verification"""

import numpy as np
def convert_gray2rgb(image):
    width, height = image.shape
    out = np.empty((width, height, 3), dtype=np.uint8)
    out[:, :, 0] = image
    out[:, :, 1] = image
    out[:, :, 2] = image
    return out


gray = df_1.values[100].reshape(28,28)  # gray scale image
gray2rgb = convert_gray2rgb(gray)

gray.shape

img = Image.fromarray(gray2rgb, 'RGB')
img.save('my1.png')
img.show()

"""Dataset for masked images"""

df_1.loc[:, 'target'] = 1
df_1.head()

"""for class 0 (non masked faces)"""



dir_url_0 = os.path.join(path, IMG_DIR_list[1])
dir_url_0

img_file_urls_0 = []
for subdir in sorted(os.listdir(dir_url_0)):
  for file in (os.listdir(os.path.join(dir_url_0, subdir))):
    img_file_urls_0.append(os.path.join(os.path.join(dir_url_0, subdir), file))

len(img_file_urls_0)

img_file_urls_0

import random
random.shuffle(img_file_urls_0)

import cv2
from PIL import Image
image_array_list_0 = []
for img_url in img_file_urls_0[0:2203]:
  img_array = cv2.imread(img_url, cv2.IMREAD_GRAYSCALE)
  img_pil = Image.fromarray(img_array)
  img_28x28 = np.array(img_pil.resize((28, 28), Image.ANTIALIAS))
  img_array = (img_28x28.flatten())
  img_array  = img_array.reshape(-1,1).T
  image_array_list_0.append(img_array.tolist()[0])

image_array_list_0 = np.array(image_array_list_0)

df_0 = pd.DataFrame(image_array_list_0)

df_0.head()

"""Verification"""

import numpy as np
def convert_gray2rgb(image):
    width, height = image.shape
    out = np.empty((width, height, 3), dtype=np.uint8)
    out[:, :, 0] = image
    out[:, :, 1] = image
    out[:, :, 2] = image
    return out


gray = df_0.values[100].reshape(28,28)  # gray scale image
gray2rgb = convert_gray2rgb(gray)

gray.shape

img = Image.fromarray(gray2rgb, 'RGB')
img.save('my0.png')
img.show()

"""Dataset for non masked images"""

df_0.loc[:, 'target'] = 0
df_0.head()

frames = [df_1, df_0]
final_df = pd.concat(frames, ignore_index=True)

final_df

"""Exploratory Data Analysis"""

final_df.shape

final_df.dtypes

final_df.describe()

#checking NULL values
final_df.isnull().any()



"""Visualisation """

sns.countplot(final_df['target']);

ax = final_df[ 'target'].value_counts().sort_values().plot(kind="barh")
totals= []
for i in ax.patches:
    totals.append(i.get_width())
print(totals)
total = sum(totals)
for i in ax.patches:
     ax.text(i.get_width()+.3, i.get_y()+.20, 
     str(round((i.get_width()/total)*100, 2))+'%', 
     fontsize=10, color='black')
ax.grid(axis="x")
plt.suptitle('Outcome', fontsize=25)
plt.show()

random_image = df_0.iloc[3, 1:]
random_image.shape
random_image = random_image.values.reshape(28,28)

plt.imshow(random_image, cmap='gray')
plt.title("without mask")

random_image = df_1.iloc[3, 1:]
random_image.shape
random_image = random_image.values.reshape(28,28)

plt.imshow(random_image, cmap='gray')
plt.title("with mask")







"""Spliting the dataset"""

X = final_df.iloc[:,:-1]
y= final_df.iloc[:,-1]

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.5,shuffle= True)

"""Normaising the data"""

std = StandardScaler()
X = std.fit_transform(X)
X = pd.DataFrame(X)
X



def plot_roc_curve(y_test, y_pred):
    ''' Plot the ROC curve for the target labels and predictions'''
    fpr, tpr, thresholds = metrics.roc_curve(y_test, y_pred, pos_label=1)
    roc_auc= metrics.auc(fpr,tpr)

    plt.title('Receiver Operating Characteristic')
    plt.plot(fpr, tpr, 'b', label = 'AUC = %0.2f' % roc_auc)
    plt.legend(loc = 'lower right')
    plt.plot([0, 1], [0, 1],'r--')
    plt.legend()
    plt.ylabel('True Positive Rate')
    plt.xlabel('False Positive Rate')
    plt.show()

def plot_confussion_matrix(y_test, y_pred):
    c_matrix = metrics.confusion_matrix(y_test, y_pred)

    # Create a dataframe with the confussion matrix values
    df_c_matrix = pd.DataFrame(c_matrix, range(c_matrix.shape[0]),
                  range(c_matrix.shape[1]))
    # Plot the confussion matrix
    sns.set(font_scale=1.5) #for label size
    sns.heatmap(df_c_matrix, annot=True,fmt='.0f',annot_kws={"size": 10})# font size
    plt.show()

"""Without Feature Selection"""

SVM_model = svm.SVC()
SVM_model.fit(X_train,y_train)
y_predict_SVM = SVM_model.predict(X_test)
print("Train score of support vector machine",SVM_model.score(X_train,y_train),"%")
print("Accuracy of support vector machine :",metrics.accuracy_score(y_test, y_predict_SVM),"%")

cv_score_SVM = cross_val_score(SVM_model, X_train, y_train, cv=5, scoring='accuracy')
cv_score_SVM

print("The accuracy using 5-fold cross validation is %.5f with std deviation of %.5f" %(np.mean(cv_score_SVM),np.std(cv_score_SVM)))

print(metrics.classification_report(y_test, y_predict_SVM))

plot_confussion_matrix(y_test,y_predict_SVM)

plot_roc_curve(y_test, y_predict_SVM)

"""Random Forest"""

rf_model = RandomForestClassifier()
rf_model.fit(X_train, y_train)
y_predict_rf = rf_model.predict(X_test)
print("Train score of random forest",rf_model.score(X_train,y_train),"%")
print("Accuracy of random forest :",metrics.accuracy_score(y_test, y_predict_rf),"%")

cv_score_rf = cross_val_score(rf_model, X_train, y_train, cv=5, scoring='accuracy')
cv_score_rf

print("The accuracy using 5-fold cross validation is %.5f with std deviation of %.5f" %(np.mean(cv_score_rf),np.std(cv_score_rf)))

print(metrics.classification_report(y_test, y_predict_rf))

plot_confussion_matrix(y_test,y_predict_rf)

plot_roc_curve(y_test,y_predict_rf)

"""KNN"""

knn_model = KNeighborsClassifier()
knn_model.fit(X_train,y_train)
print("Train score of knn classifier",knn_model.score(X_train,y_train),"%")
knn_y_pred=knn_model.predict(X_test)
print("Accuracy of knn classifier :",metrics.accuracy_score(y_test, knn_y_pred),"%")

cv_score_knn = cross_val_score(knn_model, X_train, y_train, cv=5, scoring='accuracy')
cv_score_knn

print("The accuracy using 5-fold cross validation is %.5f with std deviation of %.5f" %(np.mean(cv_score_knn),np.std(cv_score_knn)))

print(metrics.classification_report(y_test, knn_y_pred))

plot_confussion_matrix(y_test,knn_y_pred)

plot_roc_curve(y_test, knn_y_pred)



"""Recursive Feature Elimination"""

X

rfe_selector = RFE(estimator=RandomForestClassifier(), n_features_to_select=100, step=10, verbose=5)
rfe_selector.fit(X, y)
rfe_support = rfe_selector.get_support()
rfe_feature = X.loc[:,rfe_support].columns.tolist()
print('selected features : ',rfe_feature)

X_rfe = X[rfe_feature]
X_rfe

X_train_rfe, X_test_rfe, y_train_rfe, y_test_rfe = train_test_split(X_rfe, y, test_size = 0.5)





"""SVM After feature Selection"""

SVM_model_rfe = svm.SVC()
SVM_model_rfe.fit(X_train_rfe,y_train_rfe)
y_predict_SVM_rfe = SVM_model_rfe.predict(X_test_rfe)
print("Train score of support vector machine after applying feature selections : ",SVM_model_rfe.score(X_train_rfe,y_train_rfe),"%")
print("Accuracy of support vector machine after applying feature selections : ",metrics.accuracy_score(y_test_rfe, y_predict_SVM_rfe),"%")



cv_score_SVM_rfe = cross_val_score(SVM_model_rfe, X_train_rfe, y_train_rfe, cv=5, scoring='accuracy')
cv_score_SVM_rfe

print("The accuracy using 5-fold cross validation is %.5f with std deviation of %.5f" %(np.mean(cv_score_SVM_rfe),np.std(cv_score_SVM_rfe)))

print(metrics.classification_report(y_test_rfe, y_predict_SVM_rfe))

plot_confussion_matrix(y_test_rfe,y_predict_SVM_rfe)

plot_roc_curve(y_test_rfe, y_predict_SVM_rfe)

"""Random Forest After Feature Selection"""

rf_model_rfe = RandomForestClassifier()
rf_model_rfe.fit(X_train_rfe, y_train_rfe)
y_predict_rf_rfe = rf_model_rfe.predict(X_test_rfe)
print("Train score of random forest after applying feature selections : ",rf_model_rfe.score(X_train_rfe,y_train_rfe),"%")
print("Accuracy of random forest after applying feature selections  :",metrics.accuracy_score(y_test_rfe, y_predict_rf_rfe),"%")

cv_score_rf_rfe = cross_val_score(rf_model_rfe, X_train_rfe, y_train_rfe, cv=5, scoring='accuracy')
cv_score_rf_rfe

print("The accuracy using 5-fold cross validation is %.5f with std deviation of %.5f" %(np.mean(cv_score_rf_rfe),np.std(cv_score_rf_rfe)))

print(metrics.classification_report(y_test_rfe, y_predict_rf_rfe))

plot_confussion_matrix(y_test_rfe,y_predict_rf_rfe)

plot_roc_curve(y_test_rfe,y_predict_rf_rfe)

"""KNN After Feature Selection"""



knn_model_rfe = KNeighborsClassifier()
knn_model_rfe.fit(X_train_rfe,y_train_rfe)
print("Train score of knn classifier after applying feature selections : ",knn_model_rfe.score(X_train_rfe,y_train_rfe),"%")
knn_y_pred_rfe=knn_model_rfe.predict(X_test_rfe)
print("Accuracy of knn classifier after applying feature selections  :",metrics.accuracy_score(y_test_rfe, knn_y_pred_rfe),"%")

cv_score_knn_rfe = cross_val_score(knn_model_rfe, X_train_rfe, y_train_rfe, cv=5, scoring='accuracy')
cv_score_knn_rfe

print("The accuracy using 5-fold cross validation is %.5f with std deviation of %.5f" %(np.mean(cv_score_knn_rfe),np.std(cv_score_knn_rfe)))

print(metrics.classification_report(y_test_rfe, knn_y_pred_rfe))

plot_confussion_matrix(y_test_rfe,knn_y_pred_rfe)

plot_roc_curve(y_test_rfe, knn_y_pred_rfe)













